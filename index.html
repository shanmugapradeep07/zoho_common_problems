<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Python Documentation</title>
  <!-- Bootstrap CSS -->
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <style>
    /* Custom styles */
    body {
      background-color: #f8f9fa;
      color: #343a40;
    }
    .container {
      margin-top: 50px;
    }
    pre {
      background-color: #ffffff;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      padding: 20px;
      overflow-x: auto;
    }
  </style>
</head>
<body>

  <div class="container">
    <div class="row">
      <div class="col-lg-8 offset-lg-2">
        <h1 class="text-center">Python Documentation</h1>
        <p class="lead text-center">This is the documentation for your Python code.</p>

        <!-- Code Example Section -->
        <div class="card">
          <div class="card-header bg-dark text-light">
            Code Example
          </div>
          <div class="card-body">
            <pre><code class="language-python">
def swap_list(nums):
    """Use"""
    r = len(nums) - 1
    l = 0
    while l < r:
        nums[l], nums[r] = nums[r], nums[l]
        l += 1
        r -= 1
    return nums


def swap_between_intervals():
    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    k = 3
    n = len(nums)
    for i in range(0, n, k):
        r = min((i + k) - 1, n - 1)
        l = i
        while l < r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1


def schedule_combine():
    intervals = [[1, 5], [2, 7], [-2, -5], [6, 7], [8, 10]]
    intervals.sort()

    new_interval_set = [intervals[0]]
    n_interval = len(intervals)
    for i in range(1, n_interval):
        if intervals[i - 1][-1] > intervals[i][0]:
            new_interval_set[-1][-1] = max(intervals[i - 1][-1], intervals[i][0])
        else:
            new_interval_set.append(intervals[i])

    print(new_interval_set)


def longest_sequence_without_repeating_characters():
    s = 'abcabcbb'
    n = len(s)
    l = 0
    maxString = 0
    dup_set = set()
    for r in range(n):
        while s[r] in dup_set:
            dup_set.remove(s[l])
            l += 1
        dup_set.add(s[r])
        maxString = max(maxString, r - l + 1)
    return maxString


def longest_palindrome_substring():
    s = 'babcb'
    n = len(s)
    curLongIndices = (0, 0)
    resLength = 0
    for i in range(n):
        l = i
        r = i + 1 if not n % 2 else i
        while l >= 0 and r < n and s[l] == s[r]:
            if (r - l + 1) > resLength:
                resLength = r - l + 1
                curLongIndices = (l, r + 1)
            l -= 1
            r += 1
    return s[curLongIndices[0]:curLongIndices[-1]]


def count_and_say(n, s="1"):
    if n == 1:
        return s
    # for k in range(1, n):
    curValue = s[0]
    desiredString = ""
    count = 0
    s_length = len(s)
    for i in range(s_length):
        if s[i] == curValue:
            count += 1
        else:
            desiredString += str(count) + curValue
            count = 1
            curValue = s[i]
    desiredString += str(count) + curValue
    # s = desiredString
    return count_and_say(n - 1, desiredString)


def trapping_rain_water(height):
    height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
    n = len(height)
    if n <= 2:
        return 0

    storage = 0

    # minArray = [0] * n
    # minArray[0] = height[0]
    #
    # for i in range(1, n):
    #     minArray[i] = height[i - 1] if height[i - 1] > minArray[i - 1] else minArray[i - 1]
    #
    # maxArray = [0] * n
    # maxArray[-1] = height[-1]
    #
    # for i in range(n - 2, -1, -1):
    #     maxArray[i] = height[i + 1] if height[i + 1] > maxArray[i + 1] else maxArray[i + 1]
    #
    # for i in range(n):
    #     cal_sum = min(minArray[i], maxArray[i]) - height[i]
    #     if cal_sum > 0:
    #         storage += cal_sum

    l, r = 0, n - 1
    leftMax, rightMax = height[0], height[r]
    while l < r:
        if leftMax < rightMax:
            l += 1
            leftMax = max(leftMax, height[l])
            storage += leftMax - height[l]
        else:
            r -= 1
            rightMax = max(rightMax, height[r])
            storage += rightMax - height[r]

    return storage


def unique_paths():
    m = 3
    n = 7
    matrix = [[1 if i == m-1 else 0 for j in range(n)] for i in range(m)]
    for i in range(m-2,-1,-1):
        for j in range(n-1,-1,-1):
            matrix[i][j] = max(matrix[i-1][j],matrix[i][j+1])

unique_paths()
            </code></pre>
          </div>
        </div>
        
      </div>
    </div>
  </div>

  <!-- Bootstrap JS and dependencies -->
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

</body>
</html>
